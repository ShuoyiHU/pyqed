import numpy as np
import scipy.linalg as la
import time
from pyqed.qchem.dvr.hybrid_gauss_dvr_method_sweep import (
    SweepNewtonHelper, sweep_optimize_driver, 
    rebuild_Hcore_from_d, eri_JK_from_kernels_M1,
    CollocatedERIOp
)


# 1. DMRG Newton Helper
class DMRGNewtonHelper(SweepNewtonHelper):
    """
    A subclass of SweepNewtonHelper that implements the Exact Gradient and Hessian
    for the DMRG Energy Functional: E = Sum(P*h) + 0.5 * Sum(D*J).
    """
    def __init__(self, h1_nm, S_prim, eriop, D_spatial):
        super().__init__(h1_nm, S_prim, eriop)
        self.D_spatial = D_spatial # The Diagonal 2-RDM from DMRG

    def get_gradient_slice_onthefly(self, n, d_stack, P_slice):
        """
        Computes the gradient g_n for the DMRG functional.
        g_n = 2 * [ Sum_m P_nm * h_nm * d_m + Sum_k D_nk * J_k * d_n ]
        """
        Nz = self.Nz
        N  = self.N
        dn = d_stack[n]
        
        g_n = np.zeros(N, dtype=float)
        
        # --- 1. One-Electron Part (Hopping) ---
        # Sum_m P_nm * h_nm * d_m
        for m in range(Nz):
            p_nm = P_slice[n, m]
            if abs(p_nm) > 1e-12:
                # h1_nm[n, m] returns the operator matrix
                h_op = self.h1_nm[n, m]
                g_n += p_nm * (h_op @ d_stack[m])
                
        # --- 2. Two-Electron Part (Coulomb Correlation) ---
        # Sum_k D_nk * J_k * d_n
        # J_k is the potential generated by density |d_k|^2
        
        J_total = np.zeros((N, N), dtype=float)
        
        for k in range(Nz):
            d_nk = self.D_spatial[n, k]
            if abs(d_nk) > 1e-12:
                dk = d_stack[k]
                # block_nm__kl(n,n, k,k, dk, dk) returns the Matrix J_k
                J_k = self.eriop.block_nm__kl(n, n, k, k, dk, dk)
                
                # Handle sparse/diagonal return types from the library
                if J_k.ndim == 1:
                    J_total += d_nk * np.diag(J_k)
                else:
                    J_total += d_nk * J_k
                    
        # Apply Total Potential to d_n
        g_n += J_total @ dn
        
        # Scale by 2 for the derivative
        g_n *= 2.0
        
        return g_n

    def get_diagonal_hessian_block_sparse(self, n, d_stack, P_slice):
        """
        Computes the diagonal Hessian block H_nn.
        H_nn = 2 * [ P_nn * h_nn + Sum_k D_nk * J_k ]
        """
        N = self.N
        Nz = self.Nz
        
        # 1. One-Electron Hessian
        # P_nn * h_nn
        H_nn = P_slice[n, n] * self.h1_nm[n, n].copy()
        
        # 2. Two-Electron Hessian (Mean Field approximation)
        # Sum_k D_nk * J_k
        for k in range(Nz):
            d_nk = self.D_spatial[n, k]
            if abs(d_nk) > 1e-12:
                dk = d_stack[k]
                J_k = self.eriop.block_nm__kl(n, n, k, k, dk, dk)
                
                if J_k.ndim == 1:
                    H_nn += d_nk * np.diag(J_k)
                else:
                    H_nn += d_nk * J_k
                    
        H_nn *= 2.0
        return H_nn


# 2. RDM Extraction
def extract_rdms_for_helper(solver, n_spatial, verbose=False):
    """
    Extracts P (1-RDM) and D (Diagonal 2-RDM) for the helper.
    """
    rdm1_dict = solver.make_rdm()
    rdm2_dict = solver.make_rdm2()
    
    # --- 1-RDM (P) ---
    n_spin = 2 * n_spatial
    P_spin = np.zeros((n_spin, n_spin), dtype=complex)
    for i in range(n_spin):
        if i in rdm1_dict:
            rho = rdm1_dict[i]
            if hasattr(rho, 'shape') and rho.shape == (2, 2):
                P_spin[i, i] = rho[1, 1]
    for (i, j), rho_flat in rdm2_dict.items():
        rho = rho_flat.reshape(4, 4)
        val = rho[1, 2] 
        P_spin[i, j] = val
        P_spin[j, i] = np.conj(val)

    P_spatial = np.zeros((n_spatial, n_spatial), dtype=float)
    for p in range(n_spatial):
        for q in range(n_spatial):
            val = P_spin[2*p, 2*q] + P_spin[2*p+1, 2*q+1]
            P_spatial[p, q] = np.real(val)

    # --- Diagonal 2-RDM (D) ---
    D_spatial = np.zeros((n_spatial, n_spatial), dtype=float)
    def get_nn(i, j):
        if i == j: return np.real(P_spin[i, i])
        idx = (i, j) if i < j else (j, i)
        if idx not in rdm2_dict: return 0.0
        rho = rdm2_dict[idx].reshape(4,4)
        return np.real(rho[3, 3])

    for p in range(n_spatial):
        for q in range(n_spatial):
            if p == q:
                val = 2.0 * get_nn(2*p, 2*p+1)
            else:
                val  = get_nn(2*p, 2*q)     + get_nn(2*p, 2*q+1)
                val += get_nn(2*p+1, 2*q)   + get_nn(2*p+1, 2*q+1)
            D_spatial[p, q] = val
            
    if verbose: print(f"[DMRG-SCF] Extracted RDM Tr(P)={np.trace(P_spatial):.4f}")
    return P_spatial, D_spatial


# 3. Main ReOptimization for at AO level
def dmrg_ao_optimization_step(
    mol, d_stack, dummy, S_prim, ERIop, h1_nm_func, 
    z, Kz, T_prim, alphas, centers, labels, K_h, Kx_h,
    solver, Enuc=0.0, n_cycles=5, ridge=1e-3, verbose=True
):
    # 1. Extract RDMs
    P_spatial, D_spatial = extract_rdms_for_helper(solver, d_stack.shape[0], verbose=verbose)
    
    # 2. Instantiate the Custom Helper
    nh = DMRGNewtonHelper(h1_nm_func, S_prim, ERIop, D_spatial)
    
    # 3. Run Optimization using the ROBUST sweep_optimize_driver
    # This uses the Trust-Region KKT solver which prevents large energy spikes.
    d_new = sweep_optimize_driver(
        nh, 
        d_stack, 
        P_spatial, 
        S_prim,
        n_cycles=n_cycles,
        ridge=ridge,
        trust_step=1.0,
        trust_radius=1.0, 
        verbose=verbose
    )
    
    return d_new